var f=Object.defineProperty;var m=(r,e,t)=>e in r?f(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var n=(r,e,t)=>m(r,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))o(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const l of i.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&o(l)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function o(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();let y=0;class v{constructor(e,t){n(this,"id");n(this,"el");n(this,"size");n(this,"x");n(this,"y");this.size=t,this.x=null,this.y=null,this.id=++y,this.el=document.createElement("div"),this.el.style.position="absolute",this.el.style.width=`${t}px`,this.el.style.height=`${t}px`,e.appendChild(this.el),this.el.style.backgroundColor="blue",this.el.style.border="1px solid yellow",this.el.style.display="none",this.el.style.fontSize="8px",this.el.style.fontFamily="monospace",this.el.style.color="white",this.el.innerText=this.id.toString()}place(e,t){this.el.style.display="block",this.x=e,this.y=t,this.el.style.transform=`translateX(${this.size*e}px) translateY(${this.size*t}px)`}remove(){this.el.style.display="none"}}class x{constructor(e){n(this,"offset");n(this,"viewPane");n(this,"app");n(this,"tileMap");n(this,"tilePool");this.offset={x:0,y:0},this.app=e,this.tileMap=new Map,this.tilePool=[],this.viewPane=document.createElement("div"),this.viewPane.setAttribute("id","rendererViewPane"),this.app.tileContainer.appendChild(this.viewPane)}setOffset(e){this.offset.x=e.x,this.offset.y=e.y,this.viewPane.style.transform=`translateX(${this.offset.x}px) translateY(${this.offset.y}px)`}setVisibleTiles(e){for(const t of this.tileMap.values())t.x!==null&&t.y!==null&&(t.x<e.startX||t.y<e.startY||t.x>e.endX||t.y>e.endY)&&this.removeTile(t);for(let t=e.startX;t<e.endX;t++)for(let o=e.startY;o<e.endY;o++)this.addTile(t,o)}removeTile(e){e.remove(),this.tilePool.push(e),this.tileMap.delete(`${e.x},${e.y}`)}addTile(e,t){const o=`${e},${t}`;this.tileMap.has(o)||this.tileMap.set(o,this.getTile(e,t))}getTile(e,t){const o=this.tilePool.length>0?this.tilePool.pop():new v(this.viewPane,this.app.tileSize);return o.place(e,t),o}}const c=(r,e)=>{const t=document.createElement(r);return e.appendChild(t),t},a=(r,e)=>{for(const t in e)e[t]!==void 0&&(r.style[t]=e[t]);return r};class b{constructor(e){n(this,"appContainer");n(this,"mouseMoveStart");n(this,"viewport");n(this,"lastScrollOffset");n(this,"scrollOffset");n(this,"tileSize",20);n(this,"renderer");n(this,"padding",1);n(this,"helperTextContainer");n(this,"tileContainer");n(this,"tileContainerFrame");n(this,"movementEnabled",!1);this.appContainer=e,this.mouseMoveStart=null,this.viewport={width:e.clientWidth,height:e.clientHeight},this.lastScrollOffset={x:0,y:0},this.scrollOffset={x:0,y:0},this.tileContainer=this.createTileContainer(),this.tileContainerFrame=this.createTileContainerFrame(),this.helperTextContainer=this.createHelperTextContainer(),this.viewport.width=this.tileContainer.clientWidth,this.viewport.height=this.tileContainer.clientHeight,this.renderer=new x(this),this.enableMovement(),this.renderer.setVisibleTiles(this.calculateVisibleTiles()),this.addListeners()}enableMovement(){this.appContainer.style.cursor="grab",this.movementEnabled=!0}disableMovement(){this.appContainer.style.cursor="default",this.movementEnabled=!1}createHelperTextContainer(){var l;const e=c("div",this.appContainer),t=c("p",e),o=c("p",e),s=c("button",o),i=c("dialog",o);return t.innerText="Click and drag within the red box to explore the tile space.",s.innerText="What is this?",i.innerHTML=`
			<p>It's a tile-based map which allows you to move by clicking and dragging. The actual map/tile content will be added soon.</p>
			<p>Map tiles are DOM elements which are recyled as they move out of view, each displays it's ID number so you can see how they are moved around and re-used.</p>
			<p>Using a canvas to render the map would make more sense, but I thought it would be more fun to use DOM elements.</p>
			<p>The red box indicates the edges of the map viewport, the tiles which overflow this box would be hidden in a finished product but they are visible here to illustrate how the tile map works.</p>
			<p><button type="button">Close</button></p>
		`,s.addEventListener("click",()=>{this.disableMovement(),i.showModal()}),(l=i.querySelector("button"))==null||l.addEventListener("click",h=>{h.preventDefault(),this.enableMovement(),i.close()}),a(i.querySelector("button"),{fontFamily:"monospace",fontSize:"12px"}),a(e,{fontFamily:"monospace",textAlign:"center",position:"absolute",bottom:"0px",left:"0px",right:"0px",padding:"20px"}),a(t,{background:"#FFF",display:"inline-block",paddingLeft:"4px",paddingRight:"4px",marginTop:"0px",marginBottom:"0px"}),a(o,{marginTop:"10px",marginBottom:"0px"}),a(s,{fontFamily:"monospace",fontSize:"12px"}),a(i,{lineHeight:"1.3rem"}),e}createTileContainer(){const e=c("div",this.appContainer);return e.setAttribute("id","tileContainer"),a(e,{position:"absolute",left:"25%",right:"25%",bottom:"25%",top:"25%"}),e}createTileContainerFrame(){const e=c("div",this.appContainer);return e.setAttribute("id","tileContainerFrame"),a(e,{position:"absolute",left:"25%",right:"25%",bottom:"25%",top:"25%",border:"2px solid red"}),e}addListeners(){const e=i=>{if(!this.movementEnabled)return;const l="touches"in i?i.touches[0].clientX:i.clientX,h="touches"in i?i.touches[0].clientY:i.clientY;this.mouseMoveStart={x:l,y:h},this.appContainer.style.cursor="grabbing"},t=()=>{this.movementEnabled&&(this.mouseMoveStart=null,this.lastScrollOffset={x:this.scrollOffset.x,y:this.scrollOffset.y},this.renderer.setOffset(this.scrollOffset),this.renderer.setVisibleTiles(this.calculateVisibleTiles()),this.appContainer.style.cursor="grab")},o=i=>{if(!this.movementEnabled||this.mouseMoveStart===null)return;const l="touches"in i?i.touches[0].clientX:i.clientX,h="touches"in i?i.touches[0].clientY:i.clientY;this.scrollOffset.x=this.lastScrollOffset.x+(l-this.mouseMoveStart.x),this.scrollOffset.y=this.lastScrollOffset.y+(h-this.mouseMoveStart.y),this.renderer.setOffset(this.scrollOffset),this.renderer.setVisibleTiles(this.calculateVisibleTiles())};this.appContainer.addEventListener("mousedown",e),this.appContainer.addEventListener("mouseup",t),this.appContainer.addEventListener("mousemove",o),this.appContainer.addEventListener("touchstart",e),this.appContainer.addEventListener("touchend",t),this.appContainer.addEventListener("touchmove",o),new ResizeObserver(i=>{this.viewport.width=i[0].contentRect.width,this.viewport.height=i[0].contentRect.height,this.renderer.setVisibleTiles(this.calculateVisibleTiles())}).observe(this.tileContainer)}calculateVisibleTiles(){const e={x:this.scrollOffset.x+this.tileSize*this.padding,y:this.scrollOffset.y+this.tileSize*this.padding},t={width:this.viewport.width+this.tileSize*(2*this.padding),height:this.viewport.height+this.tileSize*(2*this.padding)},o=-e.x/this.tileSize,s=-e.y/this.tileSize,i=Math.ceil(t.width/this.tileSize),l=Math.ceil(t.height/this.tileSize),h=Math.floor(o),d=Math.floor(s),p=Math.ceil(o+i),u=Math.ceil(s+l);return{startX:h,startY:d,endX:p,endY:u}}start(){}}const g=new b(document.querySelector("#app"));g.start();
