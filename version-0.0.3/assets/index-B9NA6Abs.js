var y=Object.defineProperty;var v=(o,t,e)=>t in o?y(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var n=(o,t,e)=>v(o,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const l of i.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&s(l)}).observe(document,{childList:!0,subtree:!0});function e(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=e(r);fetch(r.href,i)}})();var p=(o=>(o[o.STONE=0]="STONE",o[o.GRASS=1]="GRASS",o[o.DIRT=2]="DIRT",o))(p||{});const h=(o,t)=>{const e=document.createElement(o);return t.appendChild(e),e},a=(o,t)=>{for(const e in t)t[e]!==void 0&&(o.style[e]=t[e]);return o},b={[p.STONE]:"#808080",[p.GRASS]:"#00FF00",[p.DIRT]:"#8B4513"};let g=0;class x{constructor(t,e){n(this,"id");n(this,"el");n(this,"size");n(this,"x");n(this,"y");n(this,"contentEl");this.size=e,this.x=null,this.y=null,this.id=++g,this.el=document.createElement("div"),this.el.style.position="absolute",this.el.style.width=`${e}px`,this.el.style.height=`${e}px`,t.appendChild(this.el),this.el.style.backgroundColor="#000",this.el.style.display="none",this.el.style.fontSize="8px",this.el.style.fontFamily="monospace",this.el.style.color="white",this.contentEl=h("div",this.el),a(this.contentEl,{position:"absolute",top:"0",left:"0",width:`${e}px`,height:`${e}px`,opacity:"0",transition:"opacity .5s ease"})}place(t,e){this.el.style.display="block",this.x=t,this.y=e,this.el.style.transform=`translateX(${this.size*t}px) translateY(${this.size*e}px)`}release(){this.el.style.display="none",this.contentEl.style.backgroundColor="#000",this.contentEl.style.opacity="0"}setContent(t){this.contentEl.style.backgroundColor=b[t.material],this.contentEl.style.opacity="1"}}class C{constructor(t){n(this,"offset");n(this,"viewPane");n(this,"app");n(this,"tileMap");n(this,"tilePool");this.offset={x:0,y:0},this.app=t,this.tileMap=new Map,this.tilePool=[],this.viewPane=document.createElement("div"),this.viewPane.setAttribute("id","rendererViewPane"),this.app.tileContainer.appendChild(this.viewPane)}setOffset(t){this.offset.x=t.x,this.offset.y=t.y,this.viewPane.style.transform=`translateX(${this.offset.x}px) translateY(${this.offset.y}px)`}setVisibleTiles(t){for(const e of this.tileMap.values())e.x!==null&&e.y!==null&&(e.x<t.startX||e.y<t.startY||e.x>t.endX||e.y>t.endY)&&this.removeTile(e);for(let e=t.startX;e<t.endX;e++)for(let s=t.startY;s<t.endY;s++)this.addTile(e,s)}removeTile(t){t.release(),this.tilePool.push(t),this.tileMap.delete(`${t.x},${t.y}`)}addTile(t,e){const s=`${t},${e}`;this.tileMap.has(s)||this.tileMap.set(s,this.getTile(t,e))}getTile(t,e){const s=this.tilePool.length>0?this.tilePool.pop():new x(this.viewPane,this.app.tileSize);return s.place(t,e),this.app.tileService.loadTileData(t,e,s),s}}const T=o=>{const t=Object.values(o).filter(s=>typeof s=="number"),e=Math.floor(Math.random()*t.length);return t[e]};class w{constructor(t,e,s){n(this,"data");n(this,"max");n(this,"timeout");n(this,"timer",null);n(this,"handler");if(t<=0)throw new Error("max must be a positive number greater than 0");if(e<0)throw new Error("timeout must be a positive number");this.data=[],this.max=t,this.timeout=e,this.handler=s}add(t){this.timer&&clearTimeout(this.timer),this.timer=setTimeout(()=>{this.flush()},this.timeout),this.data.push(t),this.data.length>=this.max&&this.flush()}flush(){this.handler([...this.data]),this.data.length=0}}const d={};class S{constructor(){n(this,"buffer");this.buffer=new w(200,250,t=>{setTimeout(()=>{console.log("do request");for(let e=0;e<t.length;e++){if(t[e][2].x!==t[e][0]&&t[e][2].y!==t[e][1])continue;const s=`${t[e][0]},${t[e][1]}`;d[s]||(d[s]=this.generateTile(t[e][0],t[e][1])),t[e][2].setContent(d[s])}},500)})}loadTileData(t,e,s){this.buffer.add([t,e,s])}generateTile(t,e){return{zLevel:0,material:T(p)}}}class E{constructor(t){n(this,"appContainer");n(this,"mouseMoveStart");n(this,"viewport");n(this,"lastScrollOffset");n(this,"scrollOffset");n(this,"tileSize",20);n(this,"renderer");n(this,"padding",1);n(this,"helperTextContainer");n(this,"tileContainer");n(this,"tileContainerFrame");n(this,"movementEnabled",!1);n(this,"tileService");this.appContainer=t,this.mouseMoveStart=null,this.viewport={width:t.clientWidth,height:t.clientHeight},this.lastScrollOffset={x:0,y:0},this.scrollOffset={x:0,y:0},this.tileContainer=this.createTileContainer(),this.tileContainerFrame=this.createTileContainerFrame(),this.helperTextContainer=this.createHelperTextContainer(),this.viewport.width=this.tileContainer.clientWidth,this.viewport.height=this.tileContainer.clientHeight,this.tileService=new S,this.renderer=new C(this),this.enableMovement(),this.renderer.setVisibleTiles(this.calculateVisibleTiles()),this.addListeners()}enableMovement(){this.appContainer.style.cursor="grab",this.movementEnabled=!0}disableMovement(){this.appContainer.style.cursor="default",this.movementEnabled=!1}createHelperTextContainer(){var l;const t=h("div",this.appContainer),e=h("p",t),s=h("p",t),r=h("button",s),i=h("dialog",s);return e.innerText="Click and drag around the screen to explore the map.",r.innerText="What is this?",i.innerHTML=`
			<p>An exerimental tile-based map exploring the creation of rivers and other water features... water coming soon.</p>
			<p>This latest iteration introduces asynchronous loading of tiles and generation of basic tile material colours.</p>
			<p>Tile loading is all local at the moment with a short delay to simulate a call to a server.</p>
			<h3>Next steps</h3>
			<ul style="list-style-position: inside">
				<li>Create a backend to generate and persist tile creation</li>
				<li>Generate less random, more coherent tile sets</li>
			</ul>
			<p><a href="https://github.com/mattkibbler/rivers">More information on Github</a></p>
			<h3>Previous versions</h3>
			<p><a href="https://mattkibbler.github.io/rivers/version-0.0.2/">v0.0.2</a></p>
			<p><a href="https://mattkibbler.github.io/rivers/version-0.0.1/">v0.0.1</a></p>
			<p><button type="button">Close</button></p>
		`,r.addEventListener("click",()=>{this.disableMovement(),i.showModal()}),(l=i.querySelector("button"))==null||l.addEventListener("click",c=>{c.preventDefault(),this.enableMovement(),i.close()}),a(i.querySelector("button"),{fontFamily:"monospace",fontSize:"12px"}),a(t,{fontFamily:"monospace",textAlign:"center",position:"absolute",bottom:"0px",left:"0px",right:"0px",padding:"20px"}),a(e,{background:"#FFF",display:"inline-block",paddingLeft:"4px",paddingRight:"4px",marginTop:"0px",marginBottom:"0px"}),a(s,{marginTop:"10px",marginBottom:"0px"}),a(r,{fontFamily:"monospace",fontSize:"12px"}),a(i,{lineHeight:"1.3rem"}),t}createTileContainer(){const t=h("div",this.appContainer);return t.setAttribute("id","tileContainer"),a(t,{position:"absolute",left:"25%",right:"25%",bottom:"25%",top:"25%",overflow:"hidden"}),t}createTileContainerFrame(){const t=h("div",this.appContainer);return t.setAttribute("id","tileContainerFrame"),a(t,{position:"absolute",left:"25%",right:"25%",bottom:"25%",top:"25%",border:"2px solid red"}),t}addListeners(){const t=i=>{if(!this.movementEnabled)return;const l="touches"in i?i.touches[0].clientX:i.clientX,c="touches"in i?i.touches[0].clientY:i.clientY;this.mouseMoveStart={x:l,y:c},this.appContainer.style.cursor="grabbing"},e=()=>{this.movementEnabled&&(this.mouseMoveStart=null,this.lastScrollOffset={x:this.scrollOffset.x,y:this.scrollOffset.y},this.renderer.setOffset(this.scrollOffset),this.renderer.setVisibleTiles(this.calculateVisibleTiles()),this.appContainer.style.cursor="grab")},s=i=>{if(!this.movementEnabled||this.mouseMoveStart===null)return;const l="touches"in i?i.touches[0].clientX:i.clientX,c="touches"in i?i.touches[0].clientY:i.clientY;this.scrollOffset.x=this.lastScrollOffset.x+(l-this.mouseMoveStart.x),this.scrollOffset.y=this.lastScrollOffset.y+(c-this.mouseMoveStart.y),this.renderer.setOffset(this.scrollOffset),this.renderer.setVisibleTiles(this.calculateVisibleTiles())};this.appContainer.addEventListener("mousedown",t),this.appContainer.addEventListener("mouseup",e),this.appContainer.addEventListener("mousemove",s),this.appContainer.addEventListener("touchstart",t),this.appContainer.addEventListener("touchend",e),this.appContainer.addEventListener("touchmove",s),new ResizeObserver(i=>{this.viewport.width=i[0].contentRect.width,this.viewport.height=i[0].contentRect.height,this.renderer.setVisibleTiles(this.calculateVisibleTiles())}).observe(this.tileContainer)}calculateVisibleTiles(){const t={x:this.scrollOffset.x+this.tileSize*this.padding,y:this.scrollOffset.y+this.tileSize*this.padding},e={width:this.viewport.width+this.tileSize*(2*this.padding),height:this.viewport.height+this.tileSize*(2*this.padding)},s=-t.x/this.tileSize,r=-t.y/this.tileSize,i=Math.ceil(e.width/this.tileSize),l=Math.ceil(e.height/this.tileSize),c=Math.floor(s),u=Math.floor(r),f=Math.ceil(s+i),m=Math.ceil(r+l);return{startX:c,startY:u,endX:f,endY:m}}start(){}}const O=new E(document.querySelector("#app"));O.start();
